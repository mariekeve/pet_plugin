# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PetUi
                                 A QGIS plugin
 Physiological Equivalent Temperature Simulator
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-02
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Marieke van Esch, student TU Delft, the Netherlands
        email                : marieke.vanesch@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication #Qdate
from qgis.core import QgsRasterLayer
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsProject, QgsRectangle
from osgeo import gdal, osr, ogr

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .pet_simulator_dialog import PetUiDialog
import os.path
import numpy as np
import pandas as pd
import datetime
import time
import matplotlib.pyplot as plt
from datetime import datetime
import matplotlib.image as mpimg

from .algorithm.pet_parameters import StatParameters, writer
from .algorithm.pet_parameters import DynParameters
from .algorithm.pet_parameters import window_footprint, wind_direction
from .algorithm.geotiff_creator import ArrayToGeotif, GeotifToArray, GeotifWrite, ArrayWrite, ArrayWriteG

class PetUi:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PetUi_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&PET Simulator')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.weather = DynParameters(Date=20150701, decade=1, hour=12, min=0, TT=28, FF=6, dd=100, Q=794.444, Qdif=158.88,
                 sunalt=55.3, RH=48, diurnal=0.03, Tmin= 24, Tmax = 34, U = 6)

        self.spatial = StatParameters(xmin=172075, xmax=172075 + 6, ymin=440675, ymax=440675 + 5, cellsize=1,
                                 station='herwijnen', station_lat=51.859, station_lon=5.146)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PetUi', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/pet_simulator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'PETS'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&PET Simulator'),
                action)
            self.iface.removeToolBarIcon(action)

    def clipping(self):

        self.exportdata() # read data from line edits

        root = QgsProject.instance().layerTreeRoot()
        for i in range(11):
            if i == 0:
                name = 'ahn'
            elif i == 1:
                name = 'building_height'
            elif i == 2:
                name = 'building_mask'
            elif i == 3:
                name = 'ndvi_infr'
            elif i == 4:
                name = 'ndvi_rgb'
            elif i == 5:
                name = 'Shadow_20150701_1500_LST'
            elif i == 6:
                name = 'svf'
            elif i == 7:
                name = 'svf_mask'
            elif i == 8:
                name = 'tree_height'
            elif i == 9:
                name = 'tree_mask'
            elif i == 10:
                name = 'water_mask'

            intiff = gdal.Open(f'{self.spatial.directory_in}{name}.tif')  # input from file

            up = max(self.weather.upwind, self.weather.upveg)
            side = max(self.weather.sidewind, self.weather.sideveg)
            down = max(self.weather.downwind, self.weather.downveg)
            now = max(self.weather.nowind, self.weather.noveg)
            ileft, iright, iup, idown = window_footprint(self.weather.winddir, up, side, down, now, self.spatial.cellsize)
            xleft = ileft * self.spatial.cellsize
            xright = iright * self.spatial.cellsize
            yup = iup * self.spatial.cellsize
            ydown = idown * self.spatial.cellsize

            # clip to extended research window
            outputfile = f'{self.spatial.directory_out}input\\{self.spatial.label}_{name}.tif'
            bounds = (self.spatial.xmin-xleft, self.spatial.ymin-ydown, self.spatial.xmax+xright, self.spatial.ymax+yup)
            gdal.Warp(outputfile, intiff, outputBounds=bounds)  # output to file

            self.TifToJPG(self.spatial.directory_out, 'input', f'{self.spatial.label}_{name}', large=True)

            if self.dlg.checkBox.checkState():
                ArrayWriteG(f'{self.testin}', f'{self.spatial.label}_{name}', f'{outputfile}')

            intiff = None
            raster_layer = QgsRasterLayer(outputfile, f'{name}', 'gdal')  # input from file
            if not raster_layer.isValid():
                print('Error: Invalid raster layer.')
            else:
                QgsProject.instance().addMapLayer(raster_layer)
            #layer = QgsProject.instance().mapLayersByName(f'{name}')[0]
            #myLayerNode = root.findLayer(layer.id())
            #myLayerNode.setExpanded(False)
            #myLayerNode.setItemVisibilityChecked(False)



    def addGttiffLayer(self, directory, name, im, driver, root):

        outputfile = f'{directory}{self.spatial.label}_{name}.tif'
        driver.CreateCopy(outputfile, im, strict=0)
        raster_layer = QgsRasterLayer(outputfile, f'{name}', 'gdal')  # input from file
        if not raster_layer.isValid():
            print('Error: Invalid raster layer.')
        else:
            QgsProject.instance().addMapLayer(raster_layer)
        layer = QgsProject.instance().mapLayersByName(f'{name}')[0]
        myLayerNode = root.findLayer(layer.id())
        myLayerNode.setExpanded(False)
        myLayerNode.setItemVisibilityChecked(False)

    def clipper(self, basedirectory, subdirectory, filename):

        intiff = gdal.Open(f'{basedirectory}{subdirectory}\\{filename}')
        outputfile = f'{basedirectory}clip\\{filename}'
        bounds = (self.spatial.xmin, self.spatial.ymin, self.spatial.xmax, self.spatial.ymax) #small
        gdal.Warp(outputfile, intiff, outputBounds=bounds)
        outtiff = gdal.Open(outputfile)
        return outtiff

    def TifToJPG(self, basedirectory, subdirectory, filename, binary=False, ticks= not None, large=False):
        tif = gdal.Open(f'{basedirectory}{subdirectory}\\{filename}.tif')
        tifArray = tif.ReadAsArray()
        data, metadata = GeotifToArray(tif, 1)

        #[xmin, ymin, cellsize, nrow, ncol]

        extent = metadata[0], metadata[0] + metadata[4] * metadata[2], metadata[1], metadata[1] + metadata[3] *metadata[2]
        if binary is True:
            plt.matshow(tifArray, cmap='gray', extent=extent)
            colorarr = np.linspace(np.min(tifArray), np.max(tifArray), 11)
            plt.colorbar(ticks=colorarr)
        else:
            plt.matshow(data, cmap='rainbow', extent=extent)
            colorarr = np.linspace(np.min(tifArray), np.max(tifArray), 11)
            plt.colorbar(ticks=colorarr, shrink=0.8)

        plt.title(filename)
        plt.xlabel('x') #lon
        plt.ylabel('y') #lat
        plt.axis('equal')
        plt.gca().xaxis.tick_bottom()
        plt.ticklabel_format(useOffset=False)

        if large:
            plt.savefig(f'{basedirectory}tif\\{filename}_large.jpg', bbox_inches='tight')
        else:
            plt.savefig(f'{basedirectory}tif\\{filename}.jpg', bbox_inches='tight')
        #plt.show()

    def timecalculator(self, timers, name, flag):

        elapsed_time_flag1 = flag[1] - flag[0]
        elapsed_time_flag2 = flag[2] - flag[1]
        elapsed_time_flag3 = flag[3] - flag[2]
        elapsed_time = elapsed_time_flag1 + elapsed_time_flag2 + elapsed_time_flag3
        timers[f'Elapsed time {name} (s)'] = elapsed_time
        timers[f'--- flag1 {name} read (s)'] = elapsed_time_flag1
        timers[f'--- flag2 {name} calculate (s)'] = elapsed_time_flag2
        timers[f'--- flag3 {name} write (s)'] = elapsed_time_flag3

    def timewriter(self, filename, timers):

        with open(filename, 'w') as f:
            # sum = timers.items()[1].sum()
            sum1 = sum(timers.values())/2
            for key, value in timers.items():
                # sum += value
                f.write(f'{key:35} :  {value:6.3f} : {((value / sum1) * 100):6.2f} % \n')
            f.write(f'Total time (s): {sum1:.6f}')

    def toTif(self, basedirectory):

        for i in range(11):
            if i == 0:
                name = 'ahn'
            elif i == 1:
                name = 'building_height'
            elif i == 2:
                name = 'building_mask'
            elif i == 3:
                name = 'ndvi_infr'
            elif i == 4:
                name = 'ndvi_rgb'
            elif i == 5:
                name = 'Shadow_20150701_1500_LST'
            elif i == 6:
                name = 'svf'
            elif i == 7:
                name = 'svf_mask'
            elif i == 8:
                name = 'tree_height'
            elif i == 9:
                name = 'tree_mask'
            elif i == 10:
                name = 'water_mask'
            name = f'{self.spatial.label}_{name}.tif'
            image = gdal.Open(f'{self.spatial.directory_out}clip\\{name}')
            data, metadata = GeotifToArray(image, 1)

            # only for testing
            #ArrayWrite(f'{self.spatial.directory_out}tif\\{name}', data, metadata)

    def calculate(self):

        self.exportdata()

        root = QgsProject.instance().layerTreeRoot()
        driver = gdal.GetDriverByName('GTiff')

        # --------------------------------------------------------------------------------------------------------------

        timers = dict()

        from .algorithm.fraction_area_buildings_treeregr import FaBuildingTree
        flag = []
        # import geotiffs
        flag.append(time.perf_counter())
        im1 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_building_height.tif') # large
        im2 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_building_mask.tif') # large
        im3 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_tree_height.tif') # large
        im4 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_tree_mask.tif') # large

        #calculate
        flag.append(time.perf_counter())
        #if not os.path.isfile(f'{self.spatial.directory_out}output\\wind.tiff'):
        im5 = FaBuildingTree(self.spatial, self.weather, im1, im2, im3, im4) # large

        # upscale coarse to fine
        name = 'wind_coarse'
        self.addGttiffLayer(f'{self.spatial.directory_out}scale\\', name, im5, driver, root) # test
        scaled = f'{self.spatial.directory_out}output\\{self.spatial.label}_wind.tif'  # large
        #gdal.Warp(scaled, im5, xRes=self.spatial.cellsize, yRes=self.spatial.cellsize, outputType=gdal.GDT_Float32, resampleAlg="average")
        #im5 = gdal.Open(scaled)

        # downscale coarse to fine
        data_type = gdal.GDT_Float32
        driver = gdal.GetDriverByName('GTiff')
        in_band = im5.GetRasterBand(1)
        out_ds = driver.Create(scaled, self.spatial.ncol, self.spatial.nrow, bands=1, eType=data_type)
        out_ds.SetProjection(im5.GetProjection())
        geotransform = list(im5.GetGeoTransform())
        geotransform[1] /= self.spatial.blocksize / self.spatial.cellsize
        geotransform[5] /= self.spatial.blocksize / self.spatial.cellsize
        out_ds.SetGeoTransform(geotransform)
        data = in_band.ReadAsArray(buf_xsize=self.spatial.ncol,buf_ysize=self.spatial.nrow)
        out_band = out_ds.GetRasterBand(1)
        out_band.WriteArray(data)
        im5 = out_ds

        #add layer and geotifs
        name = 'wind'
        flag.append(time.perf_counter())
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im5, driver, root)
        im1 = im2 = im3 = im4 = im5 = None
        self.dlg.label_18.setText('checked')

        #self.dlg.show()
        self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_building_height.tif')
        self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_building_mask.tif')
        self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_tree_height.tif')
        self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_tree_mask.tif')

        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_building_height')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_building_mask', binary=True)
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_tree_height')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_tree_mask', binary=True)
        self.TifToJPG(self.spatial.directory_out, 'output', f'{self.spatial.label}_wind')
        flag.append(time.perf_counter())

        # array write (only with testing)
        if self.dlg.checkBox.checkState():
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_{name}', f'{self.spatial.directory_out}output\\{self.spatial.label}_wind.tif')

        self.timecalculator(timers, name, flag)

        # --------------------------------------------------------------------------------------------------------------

        from .algorithm.ndvi_infr_large import Ndvi_infr_large
        flag = []

        #import geotiffs
        flag.append(time.perf_counter())
        im1 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_ndvi_rgb.tif') # large
        im2 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_ndvi_infr.tif') # large
        im3 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_water_mask.tif') # large
        im4 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_tree_mask.tif') # large

        # calculate
        flag.append(time.perf_counter())
        im5, im6, im7, im8 = Ndvi_infr_large(self.spatial, self.weather, im1, im2, im3, im4)  # large

        # add tif and layer
        flag.append(time.perf_counter())
        name = 'ndvi'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im5, driver, root)
        name = 'vegfra'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im6, driver, root)
        name = 'ndvi_crop_mask'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im7, driver, root)
        name = 'ndvi_tree_mask'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im8, driver, root)
        im1 = im2 = im3 = im4 = im5 = im6 = im7 = im8 = None
        self.dlg.label_13.setText('checked')

        self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_ndvi_rgb.tif')
        self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_ndvi_infr.tif')
        self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_water_mask.tif')
        self.clipper(self.spatial.directory_out, 'output', f'{self.spatial.label}_ndvi.tif')
        self.clipper(self.spatial.directory_out, 'output', f'{self.spatial.label}_vegfra.tif')
        self.clipper(self.spatial.directory_out, 'output', f'{self.spatial.label}_ndvi_crop_mask.tif')
        self.clipper(self.spatial.directory_out, 'output', f'{self.spatial.label}_ndvi_tree_mask.tif')

        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_ndvi_rgb')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_ndvi_infr')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_water_mask', binary=True)
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_ndvi')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_vegfra')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_ndvi_crop_mask')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_ndvi_tree_mask')
        flag.append(time.perf_counter())

        # write array (only for testing)
        if self.dlg.checkBox.checkState():
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_ndvi',
                        f'{self.spatial.directory_out}output\\{self.spatial.label}_ndvi.tif')
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_vegfra',
                        f'{self.spatial.directory_out}output\\{self.spatial.label}_vegfra.tif')
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_ndvi_crop_mask.tif',
                        f'{self.spatial.directory_out}output\\{self.spatial.label}_ndvi_crop_mask.tif')
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_ndvi_tree_mask',
                        f'{self.spatial.directory_out}output\\{self.spatial.label}_ndvi_tree_mask.tif')

        self.timecalculator(timers, name, flag)

        # --------------------------------------------------------------------------------------------------------------

        from .algorithm.vegetation_footprints import Vegetation_footprints
        flag = []
        #import geotiffs
        flag.append(time.perf_counter())
        im1 = gdal.Open(f'{self.spatial.directory_out}output\\{self.spatial.label}_vegfra.tif') # large

        # upscale to blocksize fine to coarse
        scaled = f'{self.spatial.directory_out}scale\\{self.spatial.label}_vegfra.tif'
        gdal.Warp(scaled, im1, xRes=self.spatial.blocksize, yRes=self.spatial.blocksize, resampleAlg="average")
        im1 = gdal.Open(scaled)

        #calculate
        flag.append(time.perf_counter())
        im2 = Vegetation_footprints(self.spatial, self.weather, im1) # small

        #downscale coarse to fine
        data_type = gdal.GDT_Float32
        driver = gdal.GetDriverByName('GTiff')
        in_band = im2.GetRasterBand(1)
        out_ds = driver.Create(scaled, self.spatial.ncol, self.spatial.nrow, bands=1, eType=data_type)
        out_ds.SetProjection(im2.GetProjection())
        geotransform = list(im2.GetGeoTransform())
        geotransform[1] /= self.spatial.blocksize / self.spatial.cellsize
        geotransform[5] /= self.spatial.blocksize / self.spatial.cellsize
        out_ds.SetGeoTransform(geotransform)
        data = in_band.ReadAsArray(buf_xsize=self.spatial.ncol, buf_ysize=self.spatial.nrow)
        out_band = out_ds.GetRasterBand(1)
        out_band.WriteArray(data)
        im2 = out_ds

        #add layer and geotiffs
        flag.append(time.perf_counter())
        name = 'vegfra_wind'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im2, driver, root)
        im1 = im2 = None
        self.dlg.label_14.setText('checked')
        self.clipper(self.spatial.directory_out, 'output', f'{self.spatial.label}_vegfra.tif')
        self.TifToJPG(self.spatial.directory_out, 'clip', f'{self.spatial.label}_vegfra')
        self.TifToJPG(self.spatial.directory_out, 'output', f'{self.spatial.label}_vegfra_wind')
        flag.append(time.perf_counter())

        # write array (only for testing)
        if self.dlg.checkBox.checkState():
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_vegfra_wind',
                    f'{self.spatial.directory_out}output\\{self.spatial.label}_vegfra_wind.tif')

        self.timecalculator(timers, name, flag)

        # --------------------------------------------------------------------------------------------------------------

        from .algorithm.skyview_footprints import Skyview_footprints
        flag = []

        #import geotif
        flag.append(time.perf_counter())
        im1 = gdal.Open(f'{self.spatial.directory_out}input\\{self.spatial.label}_svf.tif') # large

        # scale to blocksize
        scaled = f'{self.spatial.directory_out}scale\\{self.spatial.label}_svf.tif'
        gdal.Warp(scaled, im1, xRes=self.spatial.blocksize, yRes=self.spatial.blocksize, resampleAlg="average")
        im1 = gdal.Open(scaled)

        # calculate
        flag.append(time.perf_counter())
        im2 = Skyview_footprints(self.spatial, self.weather, im1) # small

        # downscale coarse to fine
        data_type = gdal.GDT_Float32
        driver = gdal.GetDriverByName('GTiff')
        in_band = im2.GetRasterBand(1)
        out_ds = driver.Create(scaled, self.spatial.ncol, self.spatial.nrow, bands=1, eType=data_type)
        out_ds.SetProjection(im2.GetProjection())
        geotransform = list(im2.GetGeoTransform())
        geotransform[1] /= self.spatial.blocksize / self.spatial.cellsize
        geotransform[5] /= self.spatial.blocksize / self.spatial.cellsize
        out_ds.SetGeoTransform(geotransform)
        data = in_band.ReadAsArray(buf_xsize=self.spatial.ncol, buf_ysize=self.spatial.nrow)
        out_band = out_ds.GetRasterBand(1)
        out_band.WriteArray(data)
        im2 = out_ds

        #add layer and write geotiffs
        flag.append(time.perf_counter())
        name = 'svf_wind'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im2, driver, root)
        im1 = im2 = None
        self.dlg.label_15.setText('checked')
        self.TifToJPG(self.spatial.directory_out, 'output', f'{self.spatial.label}_svf_wind')
        flag.append(time.perf_counter())

        #write array (only  for testing)
        if self.dlg.checkBox.checkState():
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_svf_wind',
                    f'{self.spatial.directory_out}output\\{self.spatial.label}_svf_wind.tif')

        self.timecalculator(timers, name, flag)

        # --------------------------------------------------------------------------------------------------------------
        from .algorithm.urban_heat import Urban_heat
        flag = []

        # import geotiff
        flag.append(time.perf_counter())
        im1 = gdal.Open(f'{self.spatial.directory_out}output\\{self.spatial.label}_vegfra_wind.tif') # small
        im2 = gdal.Open(f'{self.spatial.directory_out}output\\{self.spatial.label}_svf_wind.tif') # small
        self.dlg.label_16.setText('imported')
        #self.dlg.show()  refresh ??

        # calculate
        flag.append(time.perf_counter())
        im3 = Urban_heat(self.spatial, self.weather, im1, im2)
        end_time_flag2 = time.perf_counter()

        # add layer and write geotiffs
        flag.append(time.perf_counter())
        name = 'urban_heat'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im3, driver, root)
        im1 = im2 = im3 = None
        self.dlg.label_16.setText('checked')
        self.TifToJPG(self.spatial.directory_out, 'output', f'{self.spatial.label}_urban_heat')
        flag.append(time.perf_counter())

        # write array (only for testing)
        if self.dlg.checkBox.checkState():
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_urban_heat',
                    f'{self.spatial.directory_out}output\\{self.spatial.label}_urban_heat.tif')

        self.timecalculator(timers, name, flag)

        # --------------------------------------------------------------------------------------------------------------

        from .algorithm.pet_calculate import PET_calculate
        flag = []

        # import geotiff
        flag.append(time.perf_counter())
        name = f'Shadow_{self.weather.year}{self.weather.month:02d}{self.weather.day:02d}_{self.weather.hour:02d}{self.weather.min:02d}_LST'
        name = "Shadow_20150701_1500_LST"

        im1 = self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_{name}.tif') # small
        im2 = gdal.Open(f'{self.spatial.directory_out}output\\{self.spatial.label}_urban_heat.tif') # small
        im3 = gdal.Open(f'{self.spatial.directory_out}output\\{self.spatial.label}_wind.tif') # small
        im4 = self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_svf.tif')  # small
        im5 = self.clipper(self.spatial.directory_out, 'input', f'{self.spatial.label}_svf_mask.tif')  # small
        im6 = self.clipper(self.spatial.directory_out, 'output', f'{self.spatial.label}_ndvi_crop_mask.tif')  # small
        im7 = self.clipper(self.spatial.directory_out, 'output', f'{self.spatial.label}_ndvi_tree_mask.tif')  # small

        # calculate
        flag.append(time.perf_counter())
        im8 = PET_calculate(self.spatial, self.weather, im1, im2, im3, im4, im5, im6, im7) # small #nonetype

        # add layer and write geotiffs
        flag.append(time.perf_counter())
        name = 'pets'
        self.addGttiffLayer(f'{self.spatial.directory_out}output\\', name, im8, driver, root)
        im1 = im2 = im3 = im4 = im5 = im6 = im7 = None
        self.dlg.label_17.setText('checked')
        flag.append(time.perf_counter())
        self.TifToJPG(self.spatial.directory_out, 'output', f'{self.spatial.label}_pets')
        flag.append(time.perf_counter())

        # write array (only for testing)
        if self.dlg.checkBox.checkState():
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_svf.tif',
                        f'{self.spatial.directory_out}clip\\{self.spatial.label}_svf.tif')
            ArrayWriteG(f'{self.testout}', f'{self.spatial.label}_pets',
                        f'{self.spatial.directory_out}output\\{self.spatial.label}_pets.tif')
        #write time to timewriter
        self.timecalculator(timers, name, flag)
        self.timewriter(f'{self.spatial.directory_out}timewriterv1.txt', timers)


        # --------------------------------------------------------------------------------------------------------------
    def importdata(self):

        self.spatial.directory_in = self.dlg.lineEdit_3.text()
        self.spatial.directory_out = self.dlg.lineEdit_2.text()
        self.spatial.label = self.dlg.lineEdit_1.text()

        with open(f'{self.spatial.directory_out}set.csv', 'r') as fp:
            lines = fp.readlines()
            lines = [line.strip() for line in lines]
            lines = [line.split(',') for line in lines]
            self.spatial.station = lines[3][1]
            self.spatial.ymax = float(lines[4][1])
            self.spatial.xmax = float(lines[5][1])
            self.spatial.ymin = float(lines[6][1])
            self.spatial.xmin = float(lines[7][1])
            self.spatial.cellsize = float(lines[8][1])
            self.spatial.blocksize = float(lines[9][1])
            self.spatial.Resize()
            self.weather.TT = float(lines[10][1])
            self.weather.FF = float(lines[11][1])
            self.weather.dd = float(lines[12][1])
            self.weather.wind, self.weather.WE, self.weather.winddir = wind_direction(self.weather.dd, self.weather.FF)
            self.weather.Q = float(lines[13][1])
            self.weather.Qdif = float(lines[14][1])
            self.weather.sunalt = float(lines[15][1])
            self.weather.RH = float(lines[16][1])
            self.weather.diurnal = float(lines[21][1])

        self.dlg.lineEdit_7.setText(f'{self.spatial.ymax}')  # north
        self.dlg.lineEdit_6.setText(f'{self.spatial.xmax}')  # east
        self.dlg.lineEdit_5.setText(f'{self.spatial.ymin}')  # south
        self.dlg.lineEdit_4.setText(f'{self.spatial.xmin}')  # west
        self.dlg.lineEdit_17.setText(f'{self.spatial.cellsize}')  # south
        self.dlg.lineEdit_16.setText(f'{self.spatial.blocksize}')  # west
        self.dlg.lineEdit_3.setText(f'{self.spatial.directory_in}')
        self.dlg.lineEdit_2.setText(f'{self.spatial.directory_out}')
        self.dlg.lineEdit_1.setText(f'{self.spatial.label}')
        self.dlg.lineEdit_15.setText(f'{self.spatial.station}')
        self.dlg.lineEdit_8.setText(f'{self.weather.TT}')
        self.dlg.lineEdit_9.setText(f'{self.weather.FF}')
        self.dlg.lineEdit_10.setText(f'{self.weather.dd}')
        self.dlg.lineEdit_12.setText(f'{self.weather.Q}')
        self.dlg.lineEdit_13.setText(f'{self.weather.Qdif}')
        self.dlg.lineEdit_14.setText(f'{self.weather.sunalt}')
        self.dlg.lineEdit_11.setText(f'{self.weather.RH}')

        """
        f = open('D:\\tmp\\aba.txt', 'wt')
        df_KNMI = pd.read_csv(f'{self.spatial.directory_in}\\knmi_results.csv')
        
        yyyymmdd = f'{self.dlg.dateTimeEdit1.date()}'
        f.write(f' yyyymmdd {type(yyyymmdd)} {yyyymmdd}\n')
        hhmmss = f'{self.dlg.dateTimeEdit1.time()}'
        f.write(f' hhmmss {type(hhmmss)} {hhmmss}\n')
        station = self.dlg.lineEdit_15.setText(f'{self.spatial.station}')
        original_format = "%YYYY-%mm-%dd"
        parsed_date = datetime.strptime(yyyymmdd, original_format)
        desired_format = "%dd/%mm/%YYYY"
        

        parsed_time = datetime.strptime(hhmmss, "%H:%M:%S")
        hour = parsed_time.hour

        formatted_date = parsed_date.strftime(desired_format)
        

        date_string = self.dlg.dateTimeEdit1.date()
        parsed_date = eval(date_string)  # Evaluate the string to create a QDate object

        year = parsed_date.year()
        month = parsed_date.month()
        day = parsed_date.day()



        f.write(f' yearmonthday {year} {month} {day}\n')
        """


    # --------------------------------------------------------------------------------------------------------------
    def importknmi(self):

        # knmi file -> self.weather
        df_KNMI = pd.read_csv(f'{self.spatial.directory_in}\\knmi_results.csv')
        yyyymmdd = f'{self.dlg.dateTimeEdit1.date()}'
        hhmmss = f'{self.dlg.dateTimeEdit1.time()}'
        station = self.dlg.lineEdit_15.setText(f'{self.spatial.station}')


        f = open('D:\\tmp\\aba.txt', 'wt')
        f.write(f'{type(yyyymmdd)} {yyyymmdd}\n')

        original_format = "%Y-%m-%d"
        parsed_date = datetime.strptime(yyyymmdd, original_format)
        desired_format = "%d/%m/%Y"

        parsed_time = datetime.strptime(hhmmss, "%H:%M:%S")
        hour = parsed_time.hour

        formatted_date = parsed_date.strftime(desired_format)


        condition = (df_KNMI['YYYYMMDD'] == formatted_date) & (df_KNMI['H'] == hour) & (df_KNMI['station'] == station)
        filtered_rows = df_KNMI[condition]
        """
        self.dlg.lineEdit_8.setText(f'{self.weather.TT}')
        self.dlg.lineEdit_9.setText(f'{self.weather.FF}')
        self.dlg.lineEdit_10.setText(f'{self.weather.dd}')
        self.dlg.lineEdit_12.setText(f'{self.weather.Q}')
        self.dlg.lineEdit_13.setText(f'{self.weather.Qdif}')
        self.dlg.lineEdit_14.setText(f'{self.weather.sunalt}')
        self.dlg.lineEdit_11.setText(f'{self.weather.RH}')
        """
        self.dlg.lineEdit_8.setText(filtered_rows['TT'])
        self.dlg.lineEdit_8.setText(filtered_rows['FF'])
        self.dlg.lineEdit_8.setText(filtered_rows['dd'])
        self.dlg.lineEdit_8.setText(filtered_rows['Q'])
        self.dlg.lineEdit_8.setText(filtered_rows['Qdif'])
        self.dlg.lineEdit_8.setText(filtered_rows['sunalt'])
        self.dlg.lineEdit_8.setText(filtered_rows['RH'])

    def exportdata(self):

        self.spatial.ymax = float(self.dlg.lineEdit_7.text())
        self.spatial.xmax = float(self.dlg.lineEdit_6.text())  # east
        self.spatial.ymin = float(self.dlg.lineEdit_5.text())  # south
        self.spatial.xmin = float(self.dlg.lineEdit_4.text())  # west
        self.spatial.cellsize = float(self.dlg.lineEdit_17.text())  # south
        self.spatial.blocksize = float(self.dlg.lineEdit_16.text())  # west
        self.spatial.directory_in = self.dlg.lineEdit_3.text()
        self.spatial.directory_out = self.dlg.lineEdit_2.text()
        self.spatial.label = self.dlg.lineEdit_1.text()
        self.spatial.station = self.dlg.lineEdit_15.text()
        self.spatial.Resize()

        #self.weather = DynParameters()
        self.weather.TT = float(self.dlg.lineEdit_8.text())
        self.weather.FF = float(self.dlg.lineEdit_9.text())
        self.weather.dd = float(self.dlg.lineEdit_10.text())
        self.weather.wind, self.weather.WE, self.weather.winddir = wind_direction(self.weather.dd, self.weather.FF)
        self.weather.Q = float(self.dlg.lineEdit_12.text())
        self.weather.Qdif = float(self.dlg.lineEdit_13.text())
        self.weather.sunalt= float(self.dlg.lineEdit_14.text())
        self.weather.RH = float(self.dlg.lineEdit_11.text())

        with open(f'{self.spatial.directory_out}set.csv', 'wt') as f:

            f.write(f'directory_in,{self.spatial.directory_in}\n')
            f.write(f'directory_out,{self.spatial.directory_out}\n')
            f.write(f'label,{self.spatial.label}\n')
            f.write(f'station,{self.spatial.station}\n')
            f.write(f'ymax,{self.spatial.ymax:2.2f}\n')
            f.write(f'xmax,{self.spatial.xmax:2.2f}\n')
            f.write(f'ymin,{self.spatial.ymin:2.2f}\n')
            f.write(f'xmin,{self.spatial.xmin:2.2f}\n')
            f.write(f'cellsize,{self.spatial.cellsize:2.0f}\n')
            f.write(f'blocksize,{self.spatial.blocksize:2.0f}\n')
            f.write(f'TT,{self.weather.TT:2.2f}\n')
            f.write(f'FF,{self.weather.FF:2.2f}\n')
            f.write(f'dd,{self.weather.dd:2.2f}\n')
            f.write(f'Q,{self.weather.Q:2.2f}\n')
            f.write(f'Qdif,{self.weather.Qdif:2.2f}\n')
            f.write(f'sunalt,{self.weather.sunalt:2.2f}\n')
            f.write(f'RH,{self.weather.RH:2.2f}\n')
            f.write(f'wind,{self.weather.wind}\n')
            f.write(f'WE,{self.weather.WE}\n')
            f.write(f'winddir,{self.weather.winddir}\n')
            f.write(f'daynight,{self.weather.daynight}\n')
            f.write(f'diurnal,{self.weather.diurnal}\n')
            f.write(f'Tmin,{self.weather.Tmin}\n')
            f.write(f'Tmax,{self.weather.Tmax}\n')
            f.write(f'U,{self.weather.U}\n')
            # f.write(f'upwind,{self.weather.upwind}\n')
            # f.write(f'sidewind,{self.weather.sidewind}\n')
            # f.write(f'downwind,{self.weather.downwind}\n')
            # f.write(f'nowind,{self.weather.nowind}\n')
            # f.write(f'upveg,{self.weather.upveg}\n')
            # f.write(f'sideveg,{self.weather.sideveg}\n')
            # f.write(f'downveg,{self.weather.downveg}\n')
            # f.write(f'noveg,{self.weather.noveg}\n')

    def weatherknmi(self):
        self.importknmi()
        self.exportdata()

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = PetUiDialog()

        self.dlg.lineEdit_3.setText(f'{self.spatial.directory_in}')

        self.testin = f'{self.spatial.directory_out}in.txt'
        f = open(self.testin, 'wt')
        f.close()
        self.testout = f'{self.spatial.directory_out}out.txt'
        f = open(self.testout, 'wt')
        f.close()

        self.dlg.label_18.setText('')
        self.dlg.label_13.setText('')
        self.dlg.label_14.setText('')
        self.dlg.label_15.setText('')
        self.dlg.label_16.setText('')
        self.dlg.label_17.setText('')

        # show the dialog
        self.dlg.show()

        self.dlg.pushButton1.clicked.connect(self.importdata)
        self.dlg.pushButton2.clicked.connect(self.clipping)
        #self.dlg.pushButton4.clicked.connect(self.weatherknmi)
        self.dlg.pushButton3.clicked.connect(self.calculate)


        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            a=1
